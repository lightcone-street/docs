---
title: Authentication (WIP)
icon: key
---

# ACTIVE WIP, DONT TOUCH THIS PAGE, THANKS -- ARAD

<Tip>For most read-only methods, no authentication is required.</Tip>

---

## Signature authentication

Required for:

- <Badge color="blue">Post</Badge> Submit Order
- <Badge color="blue">Post</Badge> Cancel Order
- <Badge color="blue">Post</Badge> Cancel All Orders

To submit or cancel orders, you must include an Ed25519 signature signed by the relevant Solana account. It cryptographically binds the order to the wallet's ownership, ensuring orders cannot be manipulated.

1. **Create an order payload** with all required fields
2. **Sign the payload** using Ed25519 with your account's keypair
3. **Include the signature** in the request as a base58-encoded string

### Using the SDK


<Accordion title="(Recommended) Sign payload with client">


The SDK handles the 161-byte payload construction, hashing and signing:

<CodeGroup>

```rust Rust
use lightcone_sdk::program::{FullOrder, BidOrderParams};
use lightcone_sdk::api::{LightconeApiClient, SubmitOrderRequest};
use solana_sdk::signer::{keypair::Keypair, Signer};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let keypair = Keypair::new();
    let client = LightconeApiClient::new("https://tapi.lightcone.xyz");

    // Create order (buying base token with quote token)
    let mut order = FullOrder::new_bid(BidOrderParams {
        nonce: std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)?
            .as_millis() as u64,
        maker: keypair.pubkey(),
        market: market_pda,
        base_mint: base_token,   // e.g. pubkey of RWin-BTC
        quote_mint: quote_token, // e.g. pubkey of RWin-USDC
        maker_amount: 650_000,   // quote tokens you give (denom in token lamports)
        taker_amount: 1_000_000, // base tokens you receive (denom in token lamports)
        expiration: 0,
    });

    order.sign(&keypair);

    let response = client.submit_order(SubmitOrderRequest {
        maker: keypair.pubkey().to_string(),
        nonce: order.nonce,
        market_pubkey: market_pda.to_string(),
        base_token: base_token.to_string(),
        quote_token: quote_token.to_string(),
        side: 0,
        maker_amount: order.maker_amount,
        taker_amount: order.taker_amount,
        expiration: order.expiration,
        signature: hex::encode(order.signature),
        orderbook_id: "orderbook_id".to_string(),
    }).await?;

    Ok(())
}
```

</CodeGroup>

</Accordion>



### Manual signing

<Accordion title="(Advanced) Sign payload manually">


Orders are signed with Ed25519 over a Keccak256 hash of a 161-byte payload, structured as follows.

```text
Offset  Size  Field
──────  ────  ─────────────
0       8     nonce (u64 LE)
8       32    maker pubkey
40      32    market pubkey
72      32    base_token pubkey
104     32    quote_token pubkey
136     1     side (0=bid, 1=ask)
137     8     maker_amount (u64 LE)
145     8     taker_amount (u64 LE)
153     8     expiration (i64 LE)
───────────────────────────
        161   Total bytes
```

<Note>
`maker_amount` and `taker_amount` must be in token lamports (smallest token unit). API responses return scaled decimal strings for display, but order submissions use lamport values specific to the token being referenced.
</Note>

Code example:

<CodeGroup>

```rust Rust
use solana_sdk::{
    signature::{Keypair, Signer},
    pubkey::Pubkey,
};
use reqwest;
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Your wallet keypair
    let keypair = Keypair::new();
    
    // Create order data
    let order = json!({
        "maker": keypair.pubkey().to_string(),
        "nonce": 1736456789000i64,
        "market_pubkey": "FjVJXzKknRoxgdQHNfdMkzq2vswGacM3MHiZhahczBsL",
        "base_token": "5BNoPgYemyrbS4ub7MTuKczoYA7qtJZTj5m7xVanupPR",
        "quote_token": "CrhujZLfmzffVjwUTk6wL1mYeF9nRkx4MBvHmEotnaDF",
        "side": 0,
        "maker_amount": 350000i64,
        "taker_amount": 650000i64,
        "expiration": 0i64,
        "orderbook_id": "5BNoPgYe_CrhujZLf"
    });
    
    // Sign the order (implement your signing logic)
    let signature = keypair.sign_message(
        serde_json::to_string(&order)?.as_bytes()
    );
    
    // Add signature to order
    let mut order_with_sig = order.clone();
    order_with_sig["signature"] = json!(signature.to_string());
    
    // Submit order
    let client = reqwest::Client::new();
    let response = client
        .post("https://tapi.lightcone.xyz/api/orders/submit")
        .json(&order_with_sig)
        .send()
        .await?;
    
    println!("Response: {:?}", response.text().await?);
    Ok(())
}
```

```typescript TypeScript
import { Keypair } from '@solana/web3.js';
import bs58 from 'bs58';
import nacl from 'tweetnacl';

// Your wallet keypair
const keypair = Keypair.generate();

// Create order data
const order = {
  maker: keypair.publicKey.toBase58(),
  nonce: Date.now(),
  market_pubkey: "FjVJXzKknRoxgdQHNfdMkzq2vswGacM3MHiZhahczBsL",
  base_token: "5BNoPgYemyrbS4ub7MTuKczoYA7qtJZTj5m7xVanupPR",
  quote_token: "CrhujZLfmzffVjwUTk6wL1mYeF9nRkx4MBvHmEotnaDF",
  side: 0,
  maker_amount: 350000,
  taker_amount: 650000,
  expiration: 0,
  orderbook_id: "5BNoPgYe_CrhujZLf"
};

// Sign the order
const message = Buffer.from(JSON.stringify(order));
const signature = nacl.sign.detached(message, keypair.secretKey);
const signatureBase58 = bs58.encode(signature);

// Submit order
const response = await fetch('https://tapi.lightcone.xyz/api/orders/submit', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ ...order, signature: signatureBase58 })
});

console.log(await response.json());
```

```python Python
from solders.keypair import Keypair
from solders.signature import Signature
import requests
import json
import base58

# Your wallet keypair
keypair = Keypair()

# Create order data
order = {
    "maker": str(keypair.pubkey()),
    "nonce": 1736456789000,
    "market_pubkey": "FjVJXzKknRoxgdQHNfdMkzq2vswGacM3MHiZhahczBsL",
    "base_token": "5BNoPgYemyrbS4ub7MTuKczoYA7qtJZTj5m7xVanupPR",
    "quote_token": "CrhujZLfmzffVjwUTk6wL1mYeF9nRkx4MBvHmEotnaDF",
    "side": 0,
    "maker_amount": 350000,
    "taker_amount": 650000,
    "expiration": 0,
    "orderbook_id": "5BNoPgYe_CrhujZLf"
}

# Sign the order
message = json.dumps(order).encode()
signature = keypair.sign_message(message)
signature_base58 = base58.b58encode(bytes(signature)).decode()

# Submit order
order["signature"] = signature_base58
response = requests.post(
    "https://tapi.lightcone.xyz/api/orders/submit",
    json=order
)

print(response.json())
```

</CodeGroup>

</Accordion>

---

## JWT authentication

Required for:

- <Badge color="blue">Post</Badge> Get User Orders

<Accordion title="IGNORE">


JWT authentication **(TO CHANGE:)** consists of the user’s API credentials (apiKey, secret, passphrase) generated from a wallet's signature. These are used for specific API methods, as well as websockets. Requests are signed using [cryptographic method].


| Endpoint | Method | Description |
|----------|--------|-------------|
| `/auth/login_or_register_with_message` | POST | Sign an arbitrary message |
| `/auth/login_or_register_with_transaction` | POST | Sign transaction bytes |
| `/auth/logout` | POST | Clear the session cookie |

Both login endpoints accept:

| Field | Type | Description |
|-------|------|-------------|
| `pubkey_bytes` | `number[]` | Your wallet's public key as a byte array |
| `signature` | `number[]` | ED25519 signature bytes |
| `message` / `transaction` | `number[]` | The signed payload bytes |

On success, the response sets an `auth_token` cookie (HttpOnly, Secure,
SameSite=Lax) containing an RS256 JWT. If the wallet has not been seen
before, an account is created automatically.

</Accordion>

<Note>
**This endpoint requires JWT authentication:**

1. Sign an authentication message using your Solana account
2. Receive a JWT, returned as an `auth_token` HttpOnly cookie

The JWT is valid for 14 days. Subsequent requests are authenticated via the cookie; an `Authorization` header is not required.

The user is identified from the JWT - no request body is needed.
</Note>

### Obtaining a JWT

You can authenticate with the API via a message-based signature verification. The `POST /auth/login_or_register_with_message` endpoint verifies a signed payload from a Solana wallet and return a JWT session cookie.

The request body should include:
1. `message` (the original arbitrary string that was signed)
2. `signature_bs58` (the signature encoded in base58)
3. `pubkey_bytes` (the 32-byte public key as an array).

The client signs a message using their Solana wallet's private key, then submits both the original message and signature for server-side verification and receives the JWT on response header.

### Using the SDK

<Accordion title="(Recommended) Authenticate with SDK">

The SDK handles message generation, signing, and token extraction:

<CodeGroup>

```typescript TypeScript
import { LightconeClient } from '@lightcone/sdk';
import { Keypair } from '@solana/web3.js';

// Your wallet keypair
const keypair = Keypair.generate();

// Initialize client and authenticate
const client = new LightconeClient({
  apiUrl: 'https://tapi.lightcone.xyz',
});

// Authenticate - returns JWT and sets cookie automatically
const { token, userId } = await client.authenticate(keypair);

// Authenticated requests work automatically
const orders = await client.getUserOrders();
```

```python Python
from lightcone import LightconeClient
from solders.keypair import Keypair

# Your wallet keypair
keypair = Keypair()

# Initialize client and authenticate
client = LightconeClient(api_url="https://tapi.lightcone.xyz")

# Authenticate - returns JWT and sets cookie automatically
auth_result = client.authenticate(keypair)
print(f"Authenticated as user: {auth_result.user_id}")

# Authenticated requests work automatically
orders = client.get_user_orders()
```

```rust Rust
use lightcone_sdk::api::LightconeApiClient;
use solana_sdk::signer::keypair::Keypair;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Your wallet keypair
    let keypair = Keypair::new();

    // Initialize client
    let mut client = LightconeApiClient::new("https://tapi.lightcone.xyz");

    // Authenticate - stores JWT internally
    client.authenticate(&keypair).await?;

    // Authenticated requests work automatically
    let orders = client.get_user_orders().await?;

    Ok(())
}
```

</CodeGroup>

</Accordion>

### Manual Authentication

<Accordion title="(Advanced) Authenticate manually">

If you're not using the SDK, you can authenticate manually by signing a message and calling the login endpoint.

<CodeGroup>

```typescript TypeScript
import { Keypair } from '@solana/web3.js';
import nacl from 'tweetnacl';
import bs58 from 'bs58';

// Your wallet keypair
const keypair = Keypair.generate();

// 1. Generate sign-in message with timestamp
const message = `Sign in to Lightcone\n\nTimestamp: ${Date.now()}`;

// 2. Sign the message with Ed25519
const messageBytes = new TextEncoder().encode(message);
const signature = nacl.sign.detached(messageBytes, keypair.secretKey);
const signatureBs58 = bs58.encode(signature);

// 3. Call login endpoint
const response = await fetch('https://tapi.lightcone.xyz/api/auth/login_or_register_with_message', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    message,
    signature_bs58: signatureBs58,
    pubkey_bytes: Array.from(keypair.publicKey.toBytes()),
  }),
});

// 4. Extract JWT from Set-Cookie header
const setCookie = response.headers.get('set-cookie');
const token = setCookie?.match(/auth_token=([^;]+)/)?.[1];

// 5. Use token in subsequent requests
const ordersResponse = await fetch('https://tapi.lightcone.xyz/api/users/orders?wallet_address=' + keypair.publicKey.toBase58(), {
  method: 'POST',
  headers: { 'Cookie': `auth_token=${token}` },
});

console.log(await ordersResponse.json());
```

```python Python
from solders.keypair import Keypair
import nacl.signing
import base58
import requests
import time

# Your wallet keypair
keypair = Keypair()

# 1. Generate sign-in message with timestamp
message = f"Sign in to Lightcone\n\nTimestamp: {int(time.time() * 1000)}"

# 2. Sign the message with Ed25519
message_bytes = message.encode('utf-8')
signature = keypair.sign_message(message_bytes)
signature_bs58 = base58.b58encode(bytes(signature)).decode('utf-8')

# 3. Call login endpoint
response = requests.post(
    'https://tapi.lightcone.xyz/api/auth/login_or_register_with_message',
    json={
        'message': message,
        'signature_bs58': signature_bs58,
        'pubkey_bytes': list(bytes(keypair.pubkey())),
    }
)

# 4. Extract JWT from Set-Cookie header
token = None
if 'set-cookie' in response.headers:
    import re
    match = re.search(r'auth_token=([^;]+)', response.headers['set-cookie'])
    if match:
        token = match.group(1)

# 5. Use token in subsequent requests
orders_response = requests.post(
    f'https://tapi.lightcone.xyz/api/users/orders?wallet_address={keypair.pubkey()}',
    headers={'Cookie': f'auth_token={token}'}
)

print(orders_response.json())
```

```rust Rust
use solana_sdk::{
    signature::{Keypair, Signer},
    pubkey::Pubkey,
};
use reqwest::header::{HeaderMap, COOKIE, SET_COOKIE};
use serde_json::json;
use std::time::{SystemTime, UNIX_EPOCH};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Your wallet keypair
    let keypair = Keypair::new();

    // 1. Generate sign-in message with timestamp
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)?
        .as_millis();
    let message = format!("Sign in to Lightcone\n\nTimestamp: {}", timestamp);

    // 2. Sign the message with Ed25519
    let signature = keypair.sign_message(message.as_bytes());
    let signature_bs58 = bs58::encode(signature.as_ref()).into_string();

    // 3. Call login endpoint
    let client = reqwest::Client::new();
    let response = client
        .post("https://tapi.lightcone.xyz/api/auth/login_or_register_with_message")
        .json(&json!({
            "message": message,
            "signature_bs58": signature_bs58,
            "pubkey_bytes": keypair.pubkey().to_bytes(),
        }))
        .send()
        .await?;

    // 4. Extract JWT from Set-Cookie header
    let token = response
        .headers()
        .get(SET_COOKIE)
        .and_then(|v| v.to_str().ok())
        .and_then(|s| {
            s.split(';')
                .next()
                .and_then(|c| c.strip_prefix("auth_token="))
                .map(|t| t.to_string())
        })
        .expect("No auth_token in response");

    // 5. Use token in subsequent requests
    let wallet = keypair.pubkey().to_string();
    let orders_response = client
        .post(format!(
            "https://tapi.lightcone.xyz/api/users/orders?wallet_address={}",
            wallet
        ))
        .header(COOKIE, format!("auth_token={}", token))
        .send()
        .await?;

    println!("{}", orders_response.text().await?);
    Ok(())
}
```

</CodeGroup>

</Accordion>

