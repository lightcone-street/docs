---
title: Authentication
icon: key
---

<Tip>Authentication is not required for most read-only methods.</Tip>

## Signature authentication

Required for:

- <Badge color="blue">Post</Badge> orders/submit
- <Badge color="blue">Post</Badge> orders/cancel
- <Badge color="blue">Post</Badge> orders/cancel-all

Orders are cryptographically bound to the ownership of a Solana wallet. To submit or cancel orders, therefore, you must include an Ed25519 signature signed by the relevant keypair.

1. **Create the payload** with all required fields
2. **Sign the payload** using Ed25519 with your wallet's keypair
3. **Include the signature** in the request as a hex-encoded string

### Using the SDK


<Accordion title="(Recommended) Sign payload with client">


#### Create Order

<CodeGroup>

```rust Rust
use lightcone_sdk::program::{FullOrder, BidOrderParams};
use lightcone_sdk::api::{LightconeApiClient, SubmitOrderRequest};
use solana_sdk::signer::{keypair::Keypair, Signer};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let keypair = Keypair::new();
    let client = LightconeApiClient::new("https://tapi.lightcone.xyz");

    // Create order (buying base token with quote token)
    let mut order = FullOrder::new_bid(BidOrderParams {
        nonce: std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)?
            .as_millis() as u64,
        maker: keypair.pubkey(),
        market: market_pda,
        base_mint: base_token,   // e.g. pubkey of RWin-BTC
        quote_mint: quote_token, // e.g. pubkey of RWin-USDC
        maker_amount: 650_000,   // quote tokens you give (denom in token lamports)
        taker_amount: 1_000_000, // base tokens you receive (denom in token lamports)
        expiration: 0,
    });

    // Sign order
    order.sign(&keypair);

    let response = client.submit_order(SubmitOrderRequest {
        maker: keypair.pubkey().to_string(),
        nonce: order.nonce,
        market_pubkey: market_pda.to_string(),
        base_token: base_token.to_string(),
        quote_token: quote_token.to_string(),
        side: 0,
        maker_amount: order.maker_amount,
        taker_amount: order.taker_amount,
        expiration: order.expiration,
        // Providing the hex-encoded signature of the order
        signature: hex::encode(order.signature),
        orderbook_id: "orderbook_id".to_string(),
    }).await?;

    Ok(())
}
```

```typescript TypeScript
import { LightconeApiClient } from "@lightcone/sdk/api";
import {
  createSignedBidOrder,
  toSubmitRequest,
} from "@lightcone/sdk/program";
import { Keypair, PublicKey } from "@solana/web3.js";

const keypair = Keypair.generate();
const client = new LightconeApiClient("https://tapi.lightcone.xyz");

// Create and sign order (buying base token with quote token)
const order = createSignedBidOrder(
  {
    nonce: Date.now() % 0xffffffff,
    maker: keypair.publicKey,
    market: new PublicKey(marketPda),
    baseMint: new PublicKey(baseToken),   // e.g. RWin-BTC
    quoteMint: new PublicKey(quoteToken), // e.g. RWin-USDC
    makerAmount: 650_000n,   // quote tokens you give (token lamports)
    takerAmount: 1_000_000n, // base tokens you receive (token lamports)
    expiration: 0n,
  },
  keypair
);

// Submit
const response = await client.submitOrder(
  toSubmitRequest(order, "orderbook_id")
);
```

```python Python
from lightcone_sdk.api import LightconeApiClient
from lightcone_sdk.program import (
    create_signed_bid_order,
    BidOrderParams,
    to_submit_request,
)
from solders.keypair import Keypair
from solders.pubkey import Pubkey
import time

keypair = Keypair()
client = LightconeApiClient("https://tapi.lightcone.xyz")

# Create and sign order (buying base token with quote token)
order = create_signed_bid_order(
    BidOrderParams(
        nonce=int(time.time() * 1000) % 0xFFFFFFFF,
        maker=keypair.pubkey(),
        market=Pubkey.from_string(market_pda),
        base_mint=Pubkey.from_string(base_token),   # e.g. RWin-BTC
        quote_mint=Pubkey.from_string(quote_token),  # e.g. RWin-USDC
        maker_amount=650_000,    # quote tokens you give (token lamports)
        taker_amount=1_000_000,  # base tokens you receive (token lamports)
        expiration=0,
    ),
    keypair,
)

# Submit
response = await client.submit_order(
    to_submit_request(order, "orderbook_id")
)
```

</CodeGroup>

#### Cancel Order

<CodeGroup>

```rust Rust
// order_hash is returned by the submit order endpoint
let cancel_result = client.cancel_order(
    "your_order_hash",
    &keypair,
).await?;
```

```typescript TypeScript
// order_hash is returned by the submit order endpoint
const cancelResult = await client.cancelOrder("your_order_hash", keypair);
```

```python Python
# order_hash is returned by the submit order endpoint
cancel_result = client.cancel_order("your_order_hash", keypair)
```

</CodeGroup>

#### Cancel All Orders

<CodeGroup>

```rust Rust
// orderbook_id (optional) - scope cancellation to a single orderbook if added
let cancel_all_result = client.cancel_all_orders(
    Some(orderbook_id),
    &keypair,
).await?;
```

```typescript TypeScript
// orderbook_id (optional) - scope cancellation to a single orderbook
const cancelAllResult = await client.cancelAllOrders({
  orderbookId: orderbookId,
}, keypair);
```

```python Python
# orderbook_id (optional) - scope cancellation to a single orderbook
cancel_all_result = client.cancel_all_orders(
    orderbook_id=orderbook_id,
    keypair=keypair,
)
```

</CodeGroup>

</Accordion>



### Manual signing

<Accordion title="(Advanced) Sign payload manually">

#### Create Order

Orders are signed with Ed25519 over a Keccak256 hash of a 161-byte payload, structured as follows.

```text
Offset  Size  Field
──────  ────  ─────────────
0       8     nonce (u64 LE)
8       32    maker pubkey
40      32    market pubkey
72      32    base_token pubkey
104     32    quote_token pubkey
136     1     side (0=bid, 1=ask)
137     8     maker_amount (u64 LE)
145     8     taker_amount (u64 LE)
153     8     expiration (i64 LE)
───────────────────────────
        161   Total bytes
```

<Note>
`maker_amount` and `taker_amount` must be in token lamports (smallest token unit). API responses return scaled decimal strings for display, but order submissions use lamport values specific to the token being referenced.
</Note>

<CodeGroup>

```rust Rust
use solana_sdk::{
    signature::{Keypair, Signer},
    pubkey::Pubkey,
};
use reqwest;
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Your wallet keypair
    let keypair = Keypair::new();
    
    // Create order data
    let order = json!({
        "maker": keypair.pubkey().to_string(),
        "nonce": 1736456789000i64,
        "market_pubkey": "FjVJXzKknRoxgdQHNfdMkzq2vswGacM3MHiZhahczBsL",
        "base_token": "5BNoPgYemyrbS4ub7MTuKczoYA7qtJZTj5m7xVanupPR",
        "quote_token": "CrhujZLfmzffVjwUTk6wL1mYeF9nRkx4MBvHmEotnaDF",
        "side": 0,
        "amount_in": 350000i64,
        "amount_out": 650000i64,
        "expiration": 0i64,
        "orderbook_id": "5BNoPgYe_CrhujZLf"
    });
    
    // Sign the order (implement your signing logic)
    let signature = keypair.sign_message(
        serde_json::to_string(&order)?.as_bytes()
    );
    
    // Add signature to order
    let mut order_with_sig = order.clone();
    order_with_sig["signature"] = json!(signature.to_string());
    
    // Submit order
    let client = reqwest::Client::new();
    let response = client
        .post("https://tapi.lightcone.xyz/api/orders/submit")
        .json(&order_with_sig)
        .send()
        .await?;
    
    println!("Response: {:?}", response.text().await?);
    Ok(())
}
```

```typescript TypeScript
import { Keypair } from '@solana/web3.js';
import nacl from 'tweetnacl';

// Your wallet keypair
const keypair = Keypair.generate();

// Create order data
const order = {
  maker: keypair.publicKey.toBase58(),
  nonce: Date.now(),
  market_pubkey: "FjVJXzKknRoxgdQHNfdMkzq2vswGacM3MHiZhahczBsL",
  base_token: "5BNoPgYemyrbS4ub7MTuKczoYA7qtJZTj5m7xVanupPR",
  quote_token: "CrhujZLfmzffVjwUTk6wL1mYeF9nRkx4MBvHmEotnaDF",
  side: 0,
  amount_in: 350000,
  amount_out: 650000,
  expiration: 0,
  orderbook_id: "5BNoPgYe_CrhujZLf"
};

// Sign the order
const message = Buffer.from(JSON.stringify(order));
const signature = nacl.sign.detached(message, keypair.secretKey);
const signatureHex = Buffer.from(signature).toString('hex');

// Submit order
const response = await fetch('https://tapi.lightcone.xyz/api/orders/submit', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ ...order, signature: signatureHex })
});

console.log(await response.json());
```

```python Python
from solders.keypair import Keypair
import requests
import json

# Your wallet keypair
keypair = Keypair()

# Create order data
order = {
    "maker": str(keypair.pubkey()),
    "nonce": 1736456789000,
    "market_pubkey": "FjVJXzKknRoxgdQHNfdMkzq2vswGacM3MHiZhahczBsL",
    "base_token": "5BNoPgYemyrbS4ub7MTuKczoYA7qtJZTj5m7xVanupPR",
    "quote_token": "CrhujZLfmzffVjwUTk6wL1mYeF9nRkx4MBvHmEotnaDF",
    "side": 0,
    "amount_in": 350000,
    "amount_out": 650000,
    "expiration": 0,
    "orderbook_id": "5BNoPgYe_CrhujZLf"
}

# Sign the order
message = json.dumps(order).encode()
signature = keypair.sign_message(message)
signature_hex = bytes(signature).hex()

# Submit order
order["signature"] = signature_hex
response = requests.post(
    "https://tapi.lightcone.xyz/api/orders/submit",
    json=order
)

print(response.json())
```

</CodeGroup>

#### Cancel Order

To cancel a single order, sign the `order_hash` (returned by the submit order endpoint) as UTF-8 bytes:

<CodeGroup>

```rust Rust
// order_hash is returned by the submit order endpoint
let order_hash = "abc123..."; // 64-char hex string

// Sign the order hash string as UTF-8 bytes
let signature = keypair.sign_message(order_hash.as_bytes());
let signature_hex = hex::encode(signature.as_ref());

// Cancel order
let response = client
    .post("https://tapi.lightcone.xyz/api/orders/cancel")
    .json(&json!({
        "order_hash": order_hash,
        "maker": keypair.pubkey().to_string(),
        "signature": signature_hex,
    }))
    .send()
    .await?;
```

```typescript TypeScript
import nacl from 'tweetnacl';

// order_hash is returned by the submit order endpoint
const orderHash = "abc123..."; // 64-char hex string

// Sign the order hash string as UTF-8 bytes
const signature = nacl.sign.detached(
  Buffer.from(orderHash, 'utf-8'),
  keypair.secretKey
);
const signatureHex = Buffer.from(signature).toString('hex');

// Cancel order
const response = await fetch('https://tapi.lightcone.xyz/api/orders/cancel', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    order_hash: orderHash,
    maker: keypair.publicKey.toBase58(),
    signature: signatureHex,
  }),
});
```

```python Python
from solders.keypair import Keypair
import requests

# order_hash is returned by the submit order endpoint
order_hash = "abc123..."  # 64-char hex string

# Sign the order hash string as UTF-8 bytes
signature = keypair.sign_message(order_hash.encode('utf-8'))
signature_hex = bytes(signature).hex()

# Cancel order
response = requests.post(
    "https://tapi.lightcone.xyz/api/orders/cancel",
    json={
        "order_hash": order_hash,
        "maker": str(keypair.pubkey()),
        "signature": signature_hex,
    }
)
```

</CodeGroup>

#### Cancel All Orders

To cancel all orders, sign the string `"cancel_all:<user_pubkey>:<timestamp>"` where `timestamp` is the current Unix time in seconds.

<CodeGroup>

```rust Rust
use std::time::{SystemTime, UNIX_EPOCH};

// Build the cancel_all message
let timestamp = SystemTime::now()
    .duration_since(UNIX_EPOCH)?
    .as_secs() as i64;
let message = format!("cancel_all:{}:{}", keypair.pubkey(), timestamp);

// Sign the message as UTF-8 bytes
let signature = keypair.sign_message(message.as_bytes());
let signature_hex = hex::encode(signature.as_ref());

// Cancel all orders
let response = client
    .post("https://tapi.lightcone.xyz/api/orders/cancel-all")
    .json(&json!({
        "user_pubkey": keypair.pubkey().to_string(),
        "orderbook_id": "5BNoPgYe_CrhujZLf",
        "signature": signature_hex,
        "timestamp": timestamp,
    }))
    .send()
    .await?;
```

```typescript TypeScript
import nacl from 'tweetnacl';

// Build the cancel_all message
const timestamp = Math.floor(Date.now() / 1000);
const message = `cancel_all:${keypair.publicKey.toBase58()}:${timestamp}`;

// Sign the message as UTF-8 bytes
const signature = nacl.sign.detached(
  Buffer.from(message, 'utf-8'),
  keypair.secretKey
);
const signatureHex = Buffer.from(signature).toString('hex');

// Cancel all orders
const response = await fetch('https://tapi.lightcone.xyz/api/orders/cancel-all', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    user_pubkey: keypair.publicKey.toBase58(),
    orderbook_id: "5BNoPgYe_CrhujZLf",
    signature: signatureHex,
    timestamp,
  }),
});
```

```python Python
import time
from solders.keypair import Keypair
import requests

# Build the cancel_all message
timestamp = int(time.time())
pubkey = str(keypair.pubkey())
message = f"cancel_all:{pubkey}:{timestamp}"

# Sign the message as UTF-8 bytes
signature = keypair.sign_message(message.encode('utf-8'))
signature_hex = bytes(signature).hex()

# Cancel all orders
response = requests.post(
    "https://tapi.lightcone.xyz/api/orders/cancel-all",
    json={
        "user_pubkey": pubkey,
        "orderbook_id": "5BNoPgYe_CrhujZLf",
        "signature": signature_hex,
        "timestamp": timestamp,
    }
)
```

</CodeGroup>

</Accordion>

---

## JWT authentication

Required for:

- <Badge color="blue">Post</Badge> users/orders

`POST /auth/login_or_register_with_message` endpoint verifies a signed message from a Solana wallet and returns a JWT session cookie (valid for 14 days).

The request body should include:
1. `message` (the original arbitrary string that was signed)
2. `signature_bs58` (the signature encoded in base58)
3. `pubkey_bytes` (the 32-byte public key as an array).

The client signs a message with the user's Solana wallet's keypair, submits the original message and signature for server-side verification, and finally receives the JWT in the response header. 

### Using the SDK

<Accordion title="(Recommended) Authenticate with SDK">

The SDK handles message generation, signing, and token extraction:

<CodeGroup>

```rust Rust
use lightcone_sdk::api::LightconeApiClient;
use solana_sdk::signer::keypair::Keypair;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Your wallet keypair
    let keypair = Keypair::new();

    // Initialize client
    let mut client = LightconeApiClient::new("https://tapi.lightcone.xyz");

    // Authenticate - stores JWT internally
    client.authenticate(&keypair).await?;

    // Authenticated requests work automatically
    let orders = client.get_user_orders().await?;

    Ok(())
}
```

```typescript TypeScript
import { LightconeClient } from '@lightcone/sdk';
import { Keypair } from '@solana/web3.js';

// Your wallet keypair
const keypair = Keypair.generate();

// Initialize client and authenticate
const client = new LightconeClient({
  apiUrl: 'https://tapi.lightcone.xyz',
});

// Authenticate - returns JWT and sets cookie automatically
const { token, userId } = await client.authenticate(keypair);

// Authenticated requests work automatically
const orders = await client.getUserOrders();
```

```python Python
from lightcone import LightconeClient
from solders.keypair import Keypair

# Your wallet keypair
keypair = Keypair()

# Initialize client and authenticate
client = LightconeClient(api_url="https://tapi.lightcone.xyz")

# Authenticate - returns JWT and sets cookie automatically
auth_result = client.authenticate(keypair)
print(f"Authenticated as user: {auth_result.user_id}")

# Authenticated requests work automatically
orders = client.get_user_orders()
```

</CodeGroup>

</Accordion>

### Manual Authentication

<Accordion title="(Advanced) Authenticate manually">

If you're not using the SDK, you can authenticate manually by signing a message and calling the login endpoint.

<CodeGroup>

```rust Rust
use solana_sdk::{
    signature::{Keypair, Signer},
    pubkey::Pubkey,
};
use reqwest::header::{HeaderMap, COOKIE, SET_COOKIE};
use serde_json::json;
use std::time::{SystemTime, UNIX_EPOCH};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Your wallet keypair
    let keypair = Keypair::new();

    // 1. Generate sign-in message with timestamp
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)?
        .as_millis();
    let message = format!("Sign in to Lightcone\n\nTimestamp: {}", timestamp);

    // 2. Sign the message with Ed25519
    let signature = keypair.sign_message(message.as_bytes());
    let signature_bs58 = bs58::encode(signature.as_ref()).into_string();

    // 3. Call login endpoint
    let client = reqwest::Client::new();
    let response = client
        .post("https://tapi.lightcone.xyz/api/auth/login_or_register_with_message")
        .json(&json!({
            "message": message,
            "signature_bs58": signature_bs58,
            "pubkey_bytes": keypair.pubkey().to_bytes(),
        }))
        .send()
        .await?;

    // 4. Extract JWT from Set-Cookie header
    let token = response
        .headers()
        .get(SET_COOKIE)
        .and_then(|v| v.to_str().ok())
        .and_then(|s| {
            s.split(';')
                .next()
                .and_then(|c| c.strip_prefix("auth_token="))
                .map(|t| t.to_string())
        })
        .expect("No auth_token in response");

    // 5. Use token in subsequent requests
    let wallet = keypair.pubkey().to_string();
    let orders_response = client
        .post(format!(
            "https://tapi.lightcone.xyz/api/users/orders?wallet_address={}",
            wallet
        ))
        .header(COOKIE, format!("auth_token={}", token))
        .send()
        .await?;

    println!("{}", orders_response.text().await?);
    Ok(())
}
```

```typescript TypeScript
import { Keypair } from '@solana/web3.js';
import nacl from 'tweetnacl';
import bs58 from 'bs58';

// Your wallet keypair
const keypair = Keypair.generate();

// 1. Generate sign-in message with timestamp
const message = `Sign in to Lightcone\n\nTimestamp: ${Date.now()}`;

// 2. Sign the message with Ed25519
const messageBytes = new TextEncoder().encode(message);
const signature = nacl.sign.detached(messageBytes, keypair.secretKey);
const signatureBs58 = bs58.encode(signature);

// 3. Call login endpoint
const response = await fetch('https://tapi.lightcone.xyz/api/auth/login_or_register_with_message', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    message,
    signature_bs58: signatureBs58,
    pubkey_bytes: Array.from(keypair.publicKey.toBytes()),
  }),
});

// 4. Extract JWT from Set-Cookie header
const setCookie = response.headers.get('set-cookie');
const token = setCookie?.match(/auth_token=([^;]+)/)?.[1];

// 5. Use token in subsequent requests
const ordersResponse = await fetch('https://tapi.lightcone.xyz/api/users/orders?wallet_address=' + keypair.publicKey.toBase58(), {
  method: 'POST',
  headers: { 'Cookie': `auth_token=${token}` },
});

console.log(await ordersResponse.json());
```

```python Python
from solders.keypair import Keypair
import nacl.signing
import base58
import requests
import time

# Your wallet keypair
keypair = Keypair()

# 1. Generate sign-in message with timestamp
message = f"Sign in to Lightcone\n\nTimestamp: {int(time.time() * 1000)}"

# 2. Sign the message with Ed25519
message_bytes = message.encode('utf-8')
signature = keypair.sign_message(message_bytes)
signature_bs58 = base58.b58encode(bytes(signature)).decode('utf-8')

# 3. Call login endpoint
response = requests.post(
    'https://tapi.lightcone.xyz/api/auth/login_or_register_with_message',
    json={
        'message': message,
        'signature_bs58': signature_bs58,
        'pubkey_bytes': list(bytes(keypair.pubkey())),
    }
)

# 4. Extract JWT from Set-Cookie header
token = None
if 'set-cookie' in response.headers:
    import re
    match = re.search(r'auth_token=([^;]+)', response.headers['set-cookie'])
    if match:
        token = match.group(1)

# 5. Use token in subsequent requests
orders_response = requests.post(
    f'https://tapi.lightcone.xyz/api/users/orders?wallet_address={keypair.pubkey()}',
    headers={'Cookie': f'auth_token={token}'}
)

print(orders_response.json())
```

</CodeGroup>

</Accordion>


